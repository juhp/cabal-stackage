module Project
  ( findProjectRoot
  , generateProjectFile
  , runCabal
  ) where

import           System.Directory (doesFileExist, getCurrentDirectory,
                                   listDirectory)
import           System.FilePath  (takeDirectory, takeExtension, (</>))
import           SimpleCmd        (cmd_)

import           Snapshot         (constraintPkgName, readCompilerFromConfig,
                                   readConfigConstraints)

stackageProjectFile :: String
stackageProjectFile = "cabal.project.stackage"

-- | Walk up the directory tree from CWD looking for a cabal project root.
-- A root is any directory containing a .cabal file or a cabal.project file.
findProjectRoot :: IO (Maybe FilePath)
findProjectRoot = getCurrentDirectory >>= go
  where
    go dir = do
      found <- hasCabalFiles dir
      if found
        then return (Just dir)
        else do
          let parent = takeDirectory dir
          if parent == dir
            then return Nothing
            else go parent

hasCabalFiles :: FilePath -> IO Bool
hasCabalFiles dir = do
  entries    <- listDirectory dir
  hasProject <- doesFileExist (dir </> "cabal.project")
  let hasDotCabal = any ((== ".cabal") . takeExtension) entries
  return (hasProject || hasDotCabal)

-- | Generate cabal.project.stackage in the project root.
-- When userConstraints is empty, imports the Stackage config directly.
-- When userConstraints is non-empty, reads and filters the Stackage constraints
-- to remove any packages being overridden, then inlines all constraints.
generateProjectFile :: FilePath -> [String] -> IO FilePath
generateProjectFile configPath userConstraints = do
  hasProject <- doesFileExist "cabal.project"
  let header = [ "-- Generated by cabal-stackage, do not edit" ]
               ++ [ "import: cabal.project" | hasProject ]
               ++ [ "packages: ." | not hasProject ]
  body <- if null userConstraints
    then return [ "import: " ++ configPath ]
    else do
      mCompiler       <- readCompilerFromConfig configPath
      snapConstraints <- readConfigConstraints configPath
      let overridePkgs = map constraintPkgName userConstraints
          filtered     = filter (\c -> constraintPkgName c `notElem` overridePkgs) snapConstraints
          compilerLine = [ "with-compiler: " ++ c | Just c <- [mCompiler] ]
      return $ compilerLine ++ renderConstraintsBlock (filtered ++ userConstraints)
  writeFile stackageProjectFile $ unlines (header ++ body)
  return stackageProjectFile

-- | Render a list of constraint strings as cabal project file lines.
-- e.g. ["aeson ==2.0", "text ==2.1"] ->
--   ["constraints: aeson ==2.0,", "             text ==2.1"]
renderConstraintsBlock :: [String] -> [String]
renderConstraintsBlock []     = []
renderConstraintsBlock (c:cs) =
  ("constraints: " ++ c ++ if null cs then "" else ",")
  : go cs
  where
    pad = replicate (length "constraints: ") ' '
    go []     = []
    go [x]    = [pad ++ x]
    go (x:xs) = (pad ++ x ++ ",") : go xs

-- | Run cabal with the given project file and arguments.
runCabal :: FilePath -> [String] -> IO ()
runCabal projectFile args =
  cmd_ "cabal" (("--project-file=" ++ projectFile) : args)

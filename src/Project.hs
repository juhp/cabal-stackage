module Project
  ( findProjectRoot
  , generateProjectFile
  , runCabal
  ) where

import           System.Directory (doesFileExist, getCurrentDirectory,
                                   listDirectory)
import           System.FilePath  (takeDirectory, takeExtension, (</>))
import           SimpleCmd        (cmd_)

import           Snapshot         (constraintPkgName, readCompilerFromConfig,
                                   readConfigConstraints)

stackageProjectFile :: String
stackageProjectFile = "cabal-stackage.project"

stackageConfigFile :: String
stackageConfigFile = "cabal-stackage.config"

-- | Walk up the directory tree from CWD looking for a cabal project root.
-- A root is any directory containing a .cabal file or a cabal.project file.
findProjectRoot :: IO (Maybe FilePath)
findProjectRoot = getCurrentDirectory >>= go
  where
    go dir = do
      found <- hasCabalFiles dir
      if found
        then return (Just dir)
        else do
          let parent = takeDirectory dir
          if parent == dir
            then return Nothing
            else go parent

hasCabalFiles :: FilePath -> IO Bool
hasCabalFiles dir = do
  entries    <- listDirectory dir
  hasProject <- doesFileExist (dir </> "cabal.project")
  let hasDotCabal = any ((== ".cabal") . takeExtension) entries
  return (hasProject || hasDotCabal)

-- | Generate cabal-stackage.project (and cabal-stackage.config when needed).
--
-- When userConstraints is empty, cabal-stackage.project simply imports the
-- cached Stackage config; with-compiler: comes from there and -w handles
-- the Stack fallback.
--
-- When userConstraints is non-empty, the filtered Stackage constraints are
-- written to cabal-stackage.config (no with-compiler:), and
-- cabal-stackage.project imports that file and adds the user overrides as
-- a separate constraints: stanza. -w still provides the compiler.
generateProjectFile :: FilePath -> [String] -> IO FilePath
generateProjectFile configPath userConstraints = do
  hasProject <- doesFileExist "cabal.project"
  let preamble = [ "-- Generated by cabal-stackage, do not edit" ]
                 ++ [ "import: cabal.project" | hasProject ]
                 ++ [ "packages: ." | not hasProject ]
  if null userConstraints
    then
      writeFile stackageProjectFile $ unlines $
        preamble ++ [ "import: " ++ configPath ]
    else do
      snapConstraints <- readConfigConstraints configPath
      let overridePkgs = map constraintPkgName userConstraints
          filtered     = filter (\c -> constraintPkgName c `notElem` overridePkgs) snapConstraints
      mCompiler <- readCompilerFromConfig configPath
      writeFile stackageConfigFile $ unlines $
        "-- Generated by cabal-stackage, do not edit"
        : [ "with-compiler: " ++ c | Just c <- [mCompiler] ]
        ++ renderConstraintsBlock filtered
      writeFile stackageProjectFile $ unlines $
        preamble
        ++ [ "import: " ++ stackageConfigFile ]
        ++ renderConstraintsBlock userConstraints
  return stackageProjectFile

-- | Render a list of constraint strings as cabal project file lines.
-- e.g. ["aeson ==2.0", "text ==2.1"] ->
--   ["constraints: aeson ==2.0,", "             text ==2.1"]
renderConstraintsBlock :: [String] -> [String]
renderConstraintsBlock []     = []
renderConstraintsBlock (c:cs) =
  ("constraints: " ++ c ++ if null cs then "" else ",")
  : go cs
  where
    pad = replicate (length "constraints: ") ' '
    go []     = []
    go [x]    = [pad ++ x]
    go (x:xs) = (pad ++ x ++ ",") : go xs

-- | Run cabal with the given project file and arguments.
runCabal :: FilePath -> [String] -> IO ()
runCabal projectFile args =
  cmd_ "cabal" (("--project-file=" ++ projectFile) : args)
